# -*- coding: utf-8 -*-
"""CÃ³digo POO - VoAgro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mgaVTZo_qeh-tYWZyl3pEDgVB1AXbnn2

# **Projeto de POO - VoAgro**

#4.   Classe Local_server: """

import csv
import cv2
from flask import Flask, render_template
import numpy as np
import os
import pickle
import socket
import threading
import time

DW_PATH = "datawarehouse.csv"
FINALIMG_HEIGHT = 477
FINALIMG_WIDTH = 850
FINALIMG_CHANNELS = 3

#HOST_IP = socket.gethostbyname(socket.gethostname()) # Use this if running on local network
HOST_IP = "127.0.0.1" # Use this if testing via localhost
HOST_PORT = 12345

TILE_ROWS = 3
TILE_COLUMNS = 5

def tprint(lock, message): # Just so different threads don't mess up stdout when printing
    lock.acquire()
    print(message)
    lock.release()

class LocalServer:
    def __init__(self, model, host = HOST_IP, port = HOST_PORT):

        print("Initializing LocalServer instance...")

        # Creates socket to listen for connections and binds it to a TCP port
        self.host_socket = socket.socket(family = socket.AF_INET, type = socket.SOCK_STREAM)
        self.host_socket.bind((host, port))

        self.sockets = {} # Creates dictionary mapping client IP addresses to the threads handling their respective sockets
        self.keep_listening = True # Controls whether or not to keep listening for new connections/data transmissions

        self.threading_lock = threading.Lock() # Creates semaphore so different sockets don't save/access data at the same time
        self.print_lock = threading.Lock() # Used so threads can print in an organized way

        self.frames = {} # Initializes frame dict from clients
        self.stitched_image = np.zeros((FINALIMG_HEIGHT, FINALIMG_WIDTH, FINALIMG_CHANNELS), dtype = "uint8")
        self.image_nrows = TILE_ROWS
        self.image_ncolumns = TILE_COLUMNS

        self.model = model

        self.inferences = {}

        print("Local_server instance initialized.")

    def listen(self):
        # Threaded method

        while self.keep_listening is True:
            tprint(self.print_lock, "[LISTEN] Listening for connections...")
            self.host_socket.listen() # Listens for connections
            connection, address = self.host_socket.accept() # Accepts it once a connection request is received

            tprint(self.print_lock, f"[LISTEN] Connected to {address}.")
            self.sockets[address] = threading.Thread(target = self.receive_data, args = (connection, address))
            tprint(self.print_lock, f"[LISTEN] Created thread to handle {address} connection: {self.sockets[address]}")
            self.sockets[address].start() # Creates and starts new thread to handle connection
            
        tprint(self.print_lock, "[LISTEN] Stopped listening for connections.")

        addresses = list(self.sockets.keys())
        tprint(self.print_lock, "[LISTEN] Waiting for connection threads to end their tasks...")
        for address in addresses:
            self.sockets[address].join() # When self.keep_listening is set to false, closes threads once they are done closing the connections
            tprint(self.print_lock, f"[LISTEN] Terminated thread {self.sockets[address]}")
        print("[LISTEN] All connection threads closed.")

    def receive_data(self, sock, address):
        # Threaded method
        close_connection = False
        peer = sock.getpeername()
        while (self.keep_listening is True) and (close_connection is False):
            tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Waiting for new message from {address}...")
            message = {"GEO" : None,
                       "IMG" : None,
                       "INF" : None}

            # Receive data with custom application protocol
            while True:
                dtype = sock.recv(3) # Gets message data type
                tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Received header {dtype.decode('utf-8')}.")
                if dtype.decode("utf-8") == "END": # Is end of message?
                    tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: End of message.")
                    break

                if dtype.decode("utf-8") in ["GEO", "IMG", "INF", "CLS"]:
                    sock.sendall("ACK ".encode("utf-8")) # Data type is known
                else:
                    sock.sendall("NACK".encode("utf-8")) # Data type is unknown
                    tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Invalid header {dtype.decode('utf-8')}.")
                    continue

                length = sock.recv(16)
                tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Received payload length {length.decode('utf-8')}.")
                if int(length.decode("utf-8")) > 0:
                    sock.sendall("ACK ".encode("utf-8")) # Valid data length
                else:
                    sock.sendall("NACK".encode("utf-8")) # Invalid data length
                    tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Invalid payload length {length.decode('utf-8')}.")
                    continue

                rawdata = sock.recv(int(length.decode("utf-8"))*2)
                tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Received payload of size {len(rawdata)}.")
                if dtype.decode("utf-8") == "GEO": # Is geographic coordinates?
                    message["GEO"] = rawdata.decode("utf-8")
                    sock.sendall("ACK ".encode("utf-8"))

                elif dtype.decode("utf-8") == "IMG": # Is image?
                    data = pickle.loads(rawdata, fix_imports = True, encoding = "bytes")
                    message["IMG"] = data#imdecode
                    sock.sendall("ACK ".encode("utf-8"))

                elif dtype.decode("utf-8") == "INF": # Is array of inferences?
                    data = np.fromstring(rawdata, dtype = "uint8")
                    message["INF"] = data

                elif dtype.decode("utf-8") == "CLS": # Is asking to close connection?
                    tprint(self.print_lock, f"[RECEIVE_DATA] {socket}: Client closed connection.")
                    close_connection = True
                    break

            # Once the whole message is received, save the data
            tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Saving data...")
            if message["GEO"] is None or message["IMG"] is None:
                sock.sendall("REPT".encode("utf-8")) # Message is malformed, asks client to resend
                tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Unable to save, message malformed.")
            else:
                self.threading_lock.acquire() # Acquires lock to save data
                self.frames[message["GEO"]] = message["IMG"]
                self.inferences[message["GEO"]] = message["INF"]
                self.threading_lock.release() # Releases lock once data is saved
                sock.sendall("NEXT".encode("utf-8")) # Message was comprehended
                tprint(self.print_lock, f"[RECEIVE_DATA] {peer}: Data successfully saved.")
        socket.close()

    def stitch_images(self):
        self.threading_lock.acquire() # Acquires lock to read data
        keys = list(self.frames.keys())
        for key in keys: # Calculates frame position based on GEO
            tile = self.frames[key]
            tile_shape = tile.shape
            starting_y = int(key[0]) * tile_shape[0]
            starting_x = int(key[1]) * tile_shape[1]
            ending_y = starting_y + tile_shape[0]
            ending_x = starting_x + tile_shape[1]
            self.stitched_image[starting_y : ending_y, starting_x : ending_x] = tile # Places frame in its place
        self.threading_lock.release() # Releases lock once data has been read
        cv2.imwrite("webserver\\webserver_image.jpg", self.stitched_image) # Saves resulting image so webservice can use it

    def get_inferences(self, geo):
        self.threading_lock.acquire()
        image = self.frames.get(geo)
        self.inferences[geo] = self.model.predict(image) # Gets predictions from model
        self.threading_lock.release()

    def dump2datawarehouse(self, geo):
        self.threading_lock.acquire()
        image = self.frames.get(geo)
        inferences = self.inferences.get(geo)
        self.threading_lock.release()
        if image is None: # Checks if parameters are valid
            return False
        if inferences is None:
            self.get_inferences(geo)
            inferences = self.inferences.get(geo)
        if not os.path.exists(DW_PATH):
            with open(DW_PATH, mode = "w") as file: # If file doesn't exist
                pass # Create file and add header
        # Saves image and appends its path to the csv file alongside its inferences
        return True
        

    def mainloop(self):
        listening_thread = threading.Thread(target = self.listen)
        listening_thread.start()

        while self.keep_listening:
            time.sleep(2) # Delay while waiting for new images
            self.stitch_images()
            if len(self.frames) == TILE_ROWS * TILE_COLUMNS:
                self.keep_listening = False # Once all images have been received, stop

app = Flask(__name__, template_folder = "webserver")

@app.route("/")
@app.route("/index")
def home():
    return render_template("index.html")

if __name__ == "__main__":
    print("Running...")
    testserver = LocalServer("model")
    # Initializes webservice on new thread
    flaskthread = threading.Thread(target = app.run)
    flaskthread.start()    
    # Initializes server mainloop
    testserver.mainloop()

    flaskthread.join()
    print("End.")
