# -*- coding: utf-8 -*-
"""CÃ³digo POO - VoAgro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mgaVTZo_qeh-tYWZyl3pEDgVB1AXbnn2

# **Projeto de POO - VoAgro**

#4.   Classe Local_server: """

import socket

class Local_server:
    def __init__(self, allowed_clients, model, host = "127.0.0.1", port = 61234):
        #self.host = host

        # Creates socket to listen for connections and binds it to a TCP port
        self.host_socket = socket.socket(family = socket.AF_INET, type = socket.SOCK_STREAM)
        self.host_socket.bind((host, port))

        self.clients = allowed_clients # Might not be necessary
        self.sockets = {} # Creates dictionary mapping sockets to the respective client IP address
        self.keep_listening = True # Controls whether or not to keep listening for new connections/data transmissions
        
        self.frames = [] # Initializes frame list from clients
        self.stitched_image = None

        self.model = model

        self.inferences = []

    def listen(self):
        # Asynchronous method

        while self.keep_listening is True:
            print("Listening for connections...")
            self.host_socket.listen() # Listens for connections
            connection, address = self.host_socket.accept() # Accepts it once a request is received
            print(f"Connected to {address}.")
            self.sockets[address] = connection
            break # Stays here just while testing
        
        """
        # Placeholder block
        for socket in self.sockets: 
            if socket.listen() == True:
                socket.accept()
        """

    def receive_data(self, socket, address):
        # Asynchronous method

        # Placeholder block
        while self.keep_listening is True:
            data = socket.recv(1024)
            if not data:
                pass #break
            else:
                print(f"Received {data!r}")
                socket.sendall(data) # Stays here just while testing # Echoes back to client
            break # Stays here just while testing
        socket.close() # Closes connection
        self.sockets.pop(address) # Deletes socket reference
        #del self.sockets[address] # Deletes socket reference

        """
        success, data = socket.buffer_read() # Placeholder line
        if success == True:
            if type(data) == "frames": # Placeholder block
                self.frames.extend(data) # if data requires no conversion into a list of frames
                # else, convert and then append/extend
            elif type(data) == "inferences": # Placeholder block
                self.inferences.extend(data) # idem
            else:
                print("Data type invalid. No data read.")
        else:
            print("Buffer_read unsuccessful. No data read.")
        """
        
    def stitch_images(self):
        self.stiched_image = stitching_algorithm(self.frames) # Placeholder line
        self.frames = []

    def get_inferences(self):
        self.inferences.extend(self.model.predict(self.stiched_image))
        #print(predictions)

    def send_data(self): # WIP
        pass
    
    def mainloop(self):
        self.listen()
        address = list(self.sockets.keys())[0]
        self.receive_data(self.sockets[address], address)


if __name__ == "__main__":
    print("Running...")
    testserver = Local_server("list of clients", "model")
    testserver.mainloop()
    print("End.")
