# -*- coding: utf-8 -*-
"""CÃ³digo POO - VoAgro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mgaVTZo_qeh-tYWZyl3pEDgVB1AXbnn2

# **Projeto de POO - VoAgro**

#1.   Superclasse DroneT0: 
"""

import cv2
from datetime import datetime
import numpy as np
import pickle
import socket

FILES = ["drone_images\\00.jpg",
         "drone_images\\01.jpg",
         "drone_images\\02.jpg",
         "drone_images\\03.jpg",
         "drone_images\\04.jpg",
         "drone_images\\10.jpg",
         "drone_images\\11.jpg",
         "drone_images\\12.jpg",
         "drone_images\\13.jpg",
         "drone_images\\14.jpg",
         "drone_images\\20.jpg",
         "drone_images\\21.jpg",
         "drone_images\\22.jpg",
         "drone_images\\23.jpg",
         "drone_images\\24.jpg"]
#FILES = [os.path.abspath(file) for file in FILES]
#HOST_IP = "PASTE HOST IPv4" # Use this if running on local network
# or use socket.gethostbyname(socket.gethostname()) if running locally
HOST_IP = "127.0.0.1" # Use this if testing via localhost
HOST_PORT = 12345
VCAP_HEIGHT = 480
VCAP_WIDTH = 640

class DroneT0:
    def __init__(self, vidwidth = VCAP_WIDTH, vidheight = VCAP_HEIGHT):
        print("Initializing DroneT0 instance...")
        self.frames = {} # Initializes frame dictionary
        
        self.video_cap = cv2.VideoCapture(index = 0) # Creates and configures video stream
        self.video_cap.set(propId = cv2.CAP_PROP_FRAME_WIDTH, value = vidwidth)
        self.video_cap.set(propId = cv2.CAP_PROP_FRAME_HEIGHT, value = vidheight)

        self.break_mainloop = False

        self.files = FILES# Image files that we will load and send to the server to test if everything is working

        print("DroneT0 instance initialized.")

    def get_frame(self):
        ## We would use this block if were actually capturing photos, but we will instead load from disk
        """
        sucess, img = self.video_cap.read()
        if sucess == True:
            geo = self.get_geopos()
            self.frames[geo] = img
        else:
            print("Failed to capture image!")
        """
        geo = self.get_geopos()
        self.frames[geo] = cv2.imread(self.files[0])
        self.files.pop(0)
        if len(self.files) == 0:
            self.break_mainloop = True

    def get_geopos(self):
        return self.files[0].split("\\")[1].split(".")[0] # Used for testing, real world application would need actual GPS data

    def save_image(self):
        if len(self.frames) != 0:
            geo, image = self.frames.popitem()
            date = datetime.now().strftime("%Y_%m_%d-%I:%M:%S_%p")
            cv2.imwrite(f"{geo}-{date}.jpg", image) # Placeholder line

    def mainloop(self):
        while not self.break_mainloop:
            self.get_frame()
            self.save_image()

""" #2.   Subclasse DroneT1 (Super de T2): """

class DroneT1(DroneT0):
    send_inferences = False
    def __init__(self, host = HOST_IP, port = 12345, vidwidth = VCAP_WIDTH, vidheight = VCAP_HEIGHT):
        print("Initializing DroneT1 instance...")
        
        super().__init__(vidwidth, vidheight)

        self.host = host
        self.port = port
        self.socket = socket.socket(family = socket.AF_INET, type = socket.SOCK_STREAM)
        #self.socket.connect()

        print("DroneT1 instance initialized.")
    
    def set_connection(self):
        self.socket.connect((self.host, self.port))

    def send_data(self):
        """
        self.socket.sendall(b"Test1")
        data = self.socket.recv(1024)
        print(f"Received {data!r}")
        """
        
        # Prepare image to be sent
        print("[SEND_DATA] Encoding image...")
        geo, frame = self.frames.popitem()
        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 90]
        #result, imencode = cv2.imencode(".jpg", frame, encode_param)
        imgdata = pickle.dumps(frame, 0)
        img = pickle.loads(imgdata,fix_imports = True, encoding = "bytes")
        #cv2.imshow("", img)
        #cv2.waitKey()
        #imdata = np.array(imencode, dtype = "uint8")
        #str_imdata = imdata.tostring()
        print("[SEND_DATA] Image encoded.")

        message = [("GEO", geo),
                   ("IMG", imgdata)]

        if self.send_inferences is True:
            data = np.array(self.inferences.get(geo))
            infdata = pickle.dumps(data, 0)
            #str_infdata = infdata.tostring()
            message.append(("INF", infdata))

        # Send data with custom application protocol
        for header, payload in message:
            server_answer = "NACK"
            while server_answer != "ACK ": # Sends header
                print(f"[SEND_DATA] Sending header {header}...")
                self.socket.sendall(f"{header}".encode("utf-8"))
                server_answer = self.socket.recv(4).decode("utf-8")
            print(f"[SEND_DATA] {header} header delivered.")
            
            server_answer = "NACK"
            while server_answer != "ACK ": # Sends length of payload
                print(f"[SEND_DATA] Sending length of {header}...")
                self.socket.sendall(str(len(payload)).ljust(16).encode("utf-8"))
                server_answer = self.socket.recv(4).decode("utf-8")
            print(f"[SEND_DATA] {header} length delivered.")
            
            server_answer = "NACK"
            while server_answer != "ACK ": # Sends payload
                print(f"[SEND_DATA] Sending {header} payload...")
                if type(payload) == str:
                    self.socket.sendall(payload.encode("utf-8"))
                else:
                    self.socket.sendall(payload)
                server_answer = self.socket.recv(4).decode("utf-8")
            print(f"[SEND_DATA] {header} payload delivered.")

        self.socket.sendall("END".encode("utf-8"))
        if self.socket.recv(4).decode("utf-8") != "NEXT":
            print("[SEND_DATA] Message malformed, trying again...")
            return False
        else:
            print("[SEND_DATA] Data transfer successful.")
            return True

    def mainloop(self):
        self.set_connection()
        while not self.break_mainloop:
            self.get_frame()
            success = False
            while success is False:
                success = self.send_data()
            time.sleep(2) # Artificial delay
        self.socket.sendall("CLS".encode("utf-8"))

"""#3.   Subclasse DroneT2: """

class DroneT2(DroneT1):
    send_inferences = True
    def __init__(self, model, host = HOST_IP, port = HOST_PORT, vidwidth = VCAP_WIDTH, vidheight = VCAP_HEIGHT):
        print("Initializing DroneT2 instance...")
        
        super().__init__(host, port, vidwidth, vidheight)

        self.model = model
        self.inferences = {}

        print("DroneT2 instance initialized.")
    
    def get_inferences(self):
        for geo in self.frames:
            if self.inferences.get(geo) is None: # Is there an image that hasn't been processed yet?
                self.inferences[geo] = self.model.predict(self.frames[geo])
        #self.frames = []

    def mainloop(self):
        self.set_connection()
        while not self.break_mainloop:
            self.get_frame()
            self.get_inferences()
            while success is False:
                success = self.send_data()
        self.socket.sendall("CLS".encode("utf-8"))

if __name__ == "__main__":
    print("Running...")
    test1 = DroneT1()
    #test2 = DroneT2(None)
    #print(f"{test1.send_inferences} {test2.send_inferences}")
    test1.mainloop()
    print("End.")
